# Promise-limit(限制并发数量promise)

```js
function promiseLimit(arr, maxCount) {
  let current = 0;
  let callback = [];
  for (let i = 0; i < arr.length; i++) {
    doSend(arr[i]);
  }

  function doSend(item) {
    if (current < maxCount) {
      current++;
      loadImg(item).then(() => {
        current--;
        if (callback.length > 0) {
          doSend(callback.shift());
        }
      });
    } else {
      callback.push(item);
    }
  }
}
const urls = [
  { info: 'link1', time: 3000 },
  { info: 'link2', time: 2000 },
  { info: 'link3', time: 5000 },
  { info: 'link4', time: 1000 },
  { info: 'link5', time: 1200 },
  { info: 'link6', time: 2000 },
  { info: 'link7', time: 800 }
];

// 设置我们要执行的任务
function loadImg(url) {
  return new Promise((resolve, reject) => {
    console.log('----' + url.info + ' start!');
    setTimeout(() => {
      console.log(url.info + ' OK!!!');
      resolve();
    }, url.time);
  });
}

promiseLimit(urls, 3);
```

### 类实现

```js
const { urls, loadImg } = require('./mock.js');

class PromiseQueue {
  constructor(options = {}) {
    this.maxConcurrency = options.maxConcurrency;
    this.callbacks = [];
    this.currentCount = 0; //这个变量
  }

  run(task) {
    if (this.currentCount < this.maxConcurrency) {
      this.currentCount++;
      task().then(() => {
        this.currentCount--;
        if (this.callbacks.length > 0) {
          this.run(this.callbacks.shift());
        }
      });
    } else {
      this.callbacks.push(task);
    }
  }
}

const q = new PromiseQueue({
  maxConcurrency: 3
});

urls.forEach((item) => {
  q.run(() => loadImg(item));
});

```

高优先即任务插队，大概实现思路：在每个task上定义priority优先级，在取出任务的时候，按照优先级排序，然后取出执行。每一个task有优先级字段和回调函数。

请见练习场 31日练习
