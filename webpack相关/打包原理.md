# 一、Webpack

## 1、Webpack中的module是指什么?

其实webpack中提到的module概念, 和咱们平时前端开发的module概念是一样的，webpack 支持ESModule, CommonJS, AMD, Assets等.

1. #### es module

关键字 export 允许将 ESM 中的内容暴露给其他模块,
关键字 import 允许从其他模块获取引用到 ESM 中.

可以设置 package.json 中的属性来显式设置文件模块类型。 
在 package.json 中

* 设置 "type": "module" 会强制 package.json 下的所有文件使用 ECMAScript 模块。 
* 设置 "type": "commonjs" 将会强制使用 CommonJS 模块。

2. #### CommonJS

module.exports 允许将 CommonJS 中的内容暴露给其他模块,
require 允许从其他模块获取引用到 CommonJS 中.

### 所以webpack modules 如何表达自己的各种依赖关系?

* ESM import 语句
* CommonJS require() 语句
* AMD define 和 require 语句
* css/sass/less 文件中的 @import 语句。
* stylesheet url(...) 或者 HTML \<img src=...> 文件中的图片链接。

### chunk 和 bundle 的区别是什么?

1. #### Chunk

Chunk是Webpack打包过程中Modules的集合，是打包过程中的概念。
Webpack的打包是从一个入口模块开始，入口模块引用其他模块，模块再引用模块。Webpack通过引用关系逐个打包模块，这些module就形成了一个Chunk。
当然如果有多个入口模块，可能会产出多条打包路径，每条路径都会形成一个Chunk。

2. #### Bundle

Bundle是我们最终输出的一个或多个打包好的文件.

3. #### Chunk 和 Bundle 的关系?

> 大多数情况下，一个Chunk会生产一个Bundle，但是当我们开启source-map后, chunk和bundle就不是一对一的关系了，一个chunk就会对应一个bundle和一个map

##### 所以可以有这样的一个总结：Chunk是过程中的代码块，Bundle是打包结果输出的代码块, Chunk在构建完成就呈现为Bundle。

4. #### 生成Chunk的几种方式

* entry配置一个key, value为数组

```js
module.exports = {
    mode: "production",
    entry: {
        index: ["./src/index.js", "./src/add.js"]
    },
    output: {
        filename: "[name].js"
    }
};
```

可以看到这种情况, 也只会产生一个chunk，数组形式，也是产生一个chunk。

* entry配置多个key

```js
module.exports = {
    mode: "production",
    entry: {
        index: "./src/index.js",
        common: "./src/common.js"
    },
    output: {
        filename: "[name].js"
    },
};
```

可以看到这种情况, 产生了common和index两个chunk, 配置的key也就会被用为chunkName.

而output中filename字段, 将被用为bundle的名称。

* Split Chunk

咱们来改一下文件引用结构, 修改一下配置。

1. add.js 和 multiply.js 都引用common.js
```js
// add.js
import CommonFn from './common.js';

export default function add(a, b) {
    return CommonFn(a + b);
}

// multiply.js
import CommonFn from './common.js';

export default function multiply(a, b) {
    return CommonFn(a * b);
}
```

2. 安装lodash

`npm i lodash`

3. 修改index.js

```js
import {
    once
} from 'lodash';
import Add from './add.js';
import Multiply from './multiply.js';

const onceAdd = once(Add);
const addRes = onceAdd(1, 3);
const mulRes = Multiply(2, 4);

console.log(addRes);
console.log(mulRes);
```

4. 修改webpack.config.js

```js
module.exports = {
    entry: {
        main: "./src/index.js",
        other: "./src/multiply.js",
    },
    output: {
        filename: "[name].js",
    },

    optimization: {
        runtimeChunk: "single",
        splitChunks: {
            cacheGroups: {
                commons: {
                    chunks: "initial",
                    minChunks: 2,
                    minSize: 0 // 默认是20000, 这里为了演示生成commonChunks, 对最小体积不做限制
                },
                vendor: {
                    test: /node_modules/,
                    chunks: "initial",
                    name: "vendor",
                    enforce: true
                }
            },
        }
    }
}
```

5. 看一下这种配置会产生几个chunk?

配置介绍： https://webpack.docschina.org/configuration/optimization/#optimizationruntimechunk
官方runtime解释：https://www.webpackjs.com/concepts/manifest/#runtime

* entry main
* entry other
* runtimeChunk: single
* splitChunks commons
* splitChunks vendor


## 2、比较重要的一些概念

1. Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；
2. Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。

### Plugin 和 Loader 分别是做什么的? 怎么工作的?

1. Loader

一句话描述：模块转换器，将非js模块转化为webpack能识别的js模块.

loader 让 webpack 能够去处理那些非 JavaScript 文件.less/sass ——> css 

loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。
本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。

2. Plugin

一句话描述：扩展插件，在webpack运行的各个阶段，都会广播出去相对应的事件，插件可以监听到这些事件的发生，在特定的时机做相对应的事情

loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。
插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。资源优化，模块划分，环境变量的定义等等。

在 webpack 运行的生命周期中会广播出各种事件，Plugin 就可以监听这些事件，在触发时通过 webpack 提供的 API 改变输出结果。
在插件中，可以拿到 Compile 和 Compilation 的引用对象，使用它们广播事件，这些事件可以被其他插件监听到，或者对他们做出一定修改，其他插件拿到的也是变化的对象。


## 3、能简单描述一下webpack的打包流程吗？

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。
2. 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。
3. 确定入口：根据配置中的 entry 找出所有的入口文件。往下一直找，连根拔起所有的依赖。
4. 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。构成依赖图。
6. 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。
7. 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统

## 4、自我叙述

1. 进入入口文件

2. 用fs提取出文件，转化成ast树，并且提取出引入声明（ImportDeclaration）的token节点，拿到value（依赖文件的路径）。

3. 现在我们拿到了入口文件的依赖模块路径，就可以构建出一个入口文件的概括createAsset函数。如下所示

   ```js
   { id: 0,   lename: './source/entry.js',     dependencies: [ './message' ],     code:.....}
   ```

4. 接下来就是要递归的去构建入口文件依赖的依赖。

   <ul>
     <li>将入口文件的描述对象放入数组allAssets，遍历数组</li>
     <li>并且在遍历入口文件依赖，拼接绝对路径，而且将依赖的绝对路径扔入createAsset函数，构建出依赖的概述对象</li>
     <li>current Asset上增加哈希表，将依赖的relativePath做为key，id作为value</li>
     <li>并且将依赖asset push到allAssets数组中，以便下一个current asset 进入allAssets</li>
     <li>最后返回allAssets，完成了依赖图的构建</li>
   </ul>

5. 有了allAssets 依赖图，那么就要构建iife函数

## 5、手写一个迷你版的webpack

```js
//1. 找到一个入口文件
//2. 解析这个入口文件，提起他的依赖
//3. 解析入口文件依赖的依赖，递归构建出依赖图，描述出所有文件的依赖关系
//4. 把所有文件打包成一个文件

const fs = require('fs');
const path = require('path');
const babylon = require('babylon');
//babylon是一个基于babel的解析器，将代码转化成ast树

const babel = require('babel-core');
// 将ast树转化成低级浏览器也适配的js代码

const traverse = require('babel-traverse').default;
// 可以像遍历对象一样，遍历ast树

let ID = 0;
function createAsset(filename) {
  //createAssets函数，构建并且返回module对象
  const content = fs.readFileSync(filename, 'utf-8');
  const ast = babylon.parse(content, {
    sourceType: 'module'
  });

  const dependencies = [];
  traverse(ast, {
    ImportDeclaration: ({ node }) => {
      dependencies.push(node.source.value);
    }
  });

  const { code } = babel.transformFromAst(ast, null, {
    presets: ['env']
  });
  const id = ID++;
  return {
    id,
    filename,
    dependencies,
    code
  };
}
// mainAsset入口文件的概括 {
//     id: 0,
//     filename: './source/entry.js',
//     dependencies: [ './message' ],
//     code:.....
//    }

// 已经获得了单个文件的依赖，接下来尝试构建依赖图
function createGraph(entry) {
  //createGraph函数，需要注意的是要形成一个依赖和Id的映射关系mapping的数据结构
  const mainAsset = createAsset(entry);
  const allAsset = [mainAsset]; //所有模块的集合
  for (let asset of allAsset) {
    //asset单个模块
    const dirname = path.dirname(asset.filename);
    asset.mapping = {};
    asset.dependencies.forEach((relativePath) => {
      const absolutePath = path.join(dirname, relativePath);
      const childAsset = createAsset(`./${absolutePath}.js`);
      asset.mapping[relativePath] = childAsset.id; //
      allAsset.push(childAsset);
    });
  }
  return allAsset;
}

const graph = createGraph('./source/entry.js');

function bundle(graph) {
  //bundle函数主要是拼接一个iife函数，把所有的modules作为参数传入，把模块函数拼接起来
  let modules = '';
  graph.forEach((module) => {
    modules += `${module.id}:[
      function(require, module, exports){
        ${module.code}
      },
      ${JSON.stringify(module.mapping)}
    ],`;
  });

  // 0:[fn ,mapping]
//注意：这里的localRequire函数是我们在代码体中书写的require函数，通过写的相对路径来找到依赖mapping中对应的模块id，然后在调用上层的require函数，执行依赖模块的代码体，并且返回exports对象，如果该模块又依赖别的模块，同理，会找模块依赖的依赖，所以说，require函数是深度遍历，直到找到依赖的末尾，才会依次返回、执行。
  const result = `
  (function(modules){
    function require(id){
      const [fn,mapping] = modules[id];

      function localRequire(relativePath){         
        return require(mapping[relativePath]);
      }
   
    const module={ exports:{} };

    fn(localRequire, module, module.exports);

    return module.exports;

    }
    require(0);
  }({${modules}}))
  `;
  return result;
}

const res = bundle(graph);
console.log(res);

```

