### webpack5

output一些常用配置：

```js
  output: {
    publicPath:"/",//公共资源引入的公共路径
    chunkFilename:"",//非入口chunk的名称
    library:"[name]",//整个库向外暴露的变量名 + dll 配置使用，暴露库中某个方法
    library:"window"//变量名添加到哪个对象上
  },
```



内置了资源模块（assets），可以自己处理资源文件（图片、字体等），在html中引入的img也不再需要html-....那个loader

在webpack5之前都是需要通过配置一些额外的loader，例如：url-loader，file-loader。

1、raw-loader 将文件导入为[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)。

2、url-loader 将文件作为 data URI 内联到 bundle 中。

3、file-loader 将文件发送到输出目录。

```txt
asset/resource 将资源分割为单独的文件，并导出url，就是之前的 file-loader的功能.
asset/inline 将资源导出为dataURL（url(data:)）的形式，之前的 url-loader的功能.
asset/source 将资源导出为源码（source code）. 之前的 raw-loader 功能.
asset 自动选择导出为单独文件或者 dataURL形式（默认为8KB）. 之前有url-loader设置asset size limit 限制实现。
```

```js
   {
        test: /\.(jpg|png|gif|svg)$/,
        type: 'asset/resource',
        generator: {filename: 'imgs/[hash:10][ext][query]'},  //将图片打包到指定文件
   }
```

#### postcss插件预处理

首先安装postcss-loader 和postcss-preset-env，在webpack.config同级目录下新建postcss.config.js (将插件的配置写在这里)，在webpack.config 直接在loader中写postcss-loader

#### css文件单独打包插件

`mini-css-extract-plugin`插件config对象中写`filename`

#### css压缩

`const cssMinimizerWebpackPlugin = require('css-minimizer-webpack-plugin')` 生产环境下使用

如果还想在开发环境下启用 CSS 优化，请将 `optimization.minimize` 设置为 `true`:

**webpack.config.js**

```js
module.exports = {
  optimization: {minimize: true},
};
```



#### js兼容性处理

三个包 npm install -D babel-loader @babel/core @babel/preset-env webpack

```js
{
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
        options: { presets: ['@babel/preset-env']}
}
```

1. babel/preset-env 指示babel做怎样的兼容性处理，只能转化一些基本语法，promise就不能转化

2. 全部js兼容性处理 --> @babel.polyfill 引入所有的polyfill导致打出的包体积过大 

3. 按需加载 core-js

   

#### Js和html压缩

开启production模式，即可压缩



#### eslint 配置采用 airbnb风格

npm i eslint -D
npm i eslint-config-airbnb-base -D
npm i eslint-plugin-import -D

并在 page.json中配置添加

```js
  "eslintConfig": {
    "extends": "airbnb-base" // 继承airbnb风格，具体可在github中的airbnb仓库中查看详细风格
  }
```

在webpack中配置 eslint   npm i eslint-webpack-plugin -D

在webapck.config.js中配置如下

```js
//需要在文件头部加入
const ESLintPlugin = require('eslint-webpack-plugin')
//在plugins中加入如下
new ESLintPlugin({ fix: true })
```



#### 开发环境性能优化：

优化打包构建速度

优化代码调试

#### 生产环境优化：

构建速度

代码运行的性能

#### HMR模块热替换:

js： 默认不使用hmr

html：默认不是使用hmr，但是导致问题，html不能更新了 解决方法：入口加入这个html文件，并且给html加上raw-loader 或者gulp<a src="https://github.com/shinexyt/gulp-reload"> 解决html无发热更新问题</a>

样式文件：可以使用HMR 模块热更新开始hot：true ，默认开始样式热更新（style-loader默认启动热更新）



#### Source-map:（源代码到构建代码的映射）

使用了source-map情况下，一个entry，一个chunk，对应两个bundle

开发环境 速度好，调试更友好

最推崇： eval-source-map

生产环境：源代码要不要隐藏，调试要不要更友好

source-map



#### one-of：提升构建速度

让loader处理速度更快，比如让css-loader直接命中loader后，直接跳出，只匹配一个



#### 缓存：（开发环境，构建速度提升）

babel缓存，对js的解析是最多的，不能说一个js文件变化，导致所有的js文件全部的在转译一边，所以就要开启babel缓存

```js
   options: {
          presets: ['@babel/preset-env'],
          cacheDirectory: true //开启babel缓存
  }//在babel-loader中配置
```



#### 三种文件输出hash的区别<a src="https://juejin.cn/post/6844903942384517127#heading-0">掘金文章</a>

| hash类型    | 区别                                                         |
| ----------- | ------------------------------------------------------------ |
| hash        | hash是根据整个项目构建，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值 |
| chunkhash   | chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的代码块（chunk），生成对应的哈希值，某文件变化时只有该文件对应代码块（chunk）的hash会变化 |
| contentHash | 每一个代码块（chunk）中的js和css输出文件都会独立生成一个hash，当某一个代码块（chunk）中的js源文件被修改时，只有该代码块（chunk）输出的js文件的hash会发生变化 |



#### Tree shaking 去除无用代码

两个条件：使用es6     开启production

在package.json 中配`"sideEffects:[\*.css,\*.less]"`表示不用tree shaking的代码



#### optimization 

#### Code splitting

1. 多入口文件，entry写成对象形式，一个入口有一个bundle，自动分包。

2. ```js
   optimization: {
     splitChunks: {
       chunks: 'all',       //那些文件都要被split，全部 async异步 initial 只入口文件
       minSize:30*1024,     // 分割的chunk最小为30kb
       minChunks：1，        // 要提取的第三方模块最少被一个chunk被引用一次
     	maxAsyncRequests:5   // 按需加载并行加载文件的最大数量
       maxInitIalRequests:3 // 入口js文件最大并行请求数量
       cacheGroups：{       //  分割的chunk组
         verdors：{
           test：/node_modules/,
           priority: -10  
         },
       }
     }
   }
   ```
   
3. 可以将node_modules中的代码（安装的一些依赖）单独打包一个chunk最终输出。

​		即使在多入口的情况下，自动分析多入口chunk有没有公共文件，有的话会将公共文件单独打包成一个chunk。

3. 使用import动态导入语法，能将某个模块单独打包

`runtingChunk："single"` 代表模块加载运行的代码，单独分离出来。

> 优化持久化缓存的, runtime 指的是 webpack 的运行环境(具体作用就是模块解析, 加载) 和 模块信息清单, 模块信息清单在每次有模块变更(hash 变更)时都会变更, 所以我们想把这部分代码单独打包出来, 配合后端缓存策略, 这样就不会因为某个模块的变更导致包含**模块信息的模块**(通常会被包含在最后一个 bundle 中)缓存失效. optimization.runtimeChunk 就是告诉 webpack 是否要把这部分单独打包出来.



#### 懒加载（触发某些条件加载）

把import语法放在回调函数中进行 简单的demo 触发点击，加载模块

```js
document.getElementsByClassName('target')[0].addEventListener('click', () => {
  import(/* webpackChunkName: "test"*/ './test').then(({ bar }) => bar());
});
```

#### 预加载（等其他文件加载完毕，等浏览器空闲，在加载资源）

prefetch： 在文件使用之前会加载文件。`webpackPreFetch:true`

在用户使用的时候已经加载好了，不会堵塞资源、网络。兼容性差

#### 正常加载（并行加载，同一时间加载多个文件，没有先后顺序）



#### Externals: 拒绝某些包被打入到我们的bundle中，而是通过模版html中用script标签cdn引入方式达成目的。

```js
externals:{jquery:jQuery }//忽略的库名---npm下载的包名
```



#### dll技术，对某些库（第三方库进行单独打包）

```js
module.exports={
	entry:{jquery:["jquery"]},
	output:{
		filaname:'[name].js'
		path:resolve(__dirname,"dll"),
		library:'[name]_[hash]' //打包的库里面向外面暴露出去的内容叫什么名字
	},
}
```

对一些我们常用但构建时间又长的的包（react，react-dom等等）缓存在dll中，在后续的构建中，直接跳过我们dll的部分，缩短构建时间。

<a href="https://www.1024sou.com/article/289012.html">你应该不在需要dll了</a>，对于dll，优秀的vue和react脚手架都已经废弃了，webpack4以上打包性能已经足够优秀。

