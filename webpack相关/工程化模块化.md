# 前端工程化

#### 一 前端工程化（流程解决方案）

1. 技术选型
2. 统一规范（提交规范，代码风格）
3. 测试、布署（CND）、监控（埋点）
4. 性能优化（根据module进行懒加载）

> ​            渲染： 1. 重绘： vue的异步更新（类似这种思想） 、 利用事件代理绑定事件在父元素上 
>
> ​	            		 2. 元素懒加载：轮播图，虚拟滚动等等，离开我们视线的dom及时销毁
>
> ​    代码结构：1. 模块懒加载，对于单个页面只加载对应的逻辑块trunk，在路由操作、依赖的按需加载（e-chart）
>
> ​						2. 层级设计
>
> ​            网络：减少网络请求次数，一些接口设计

5. 模块化重构，方便重构，需求迭代（代码逻辑相同一个chunk，多chunk）

#### 二 `webpack`是实现前端工程的一部分

`Loader`：制定文件夹下的文件都会经过loader转化处理，变成js文件。走同一逻辑，module中rules的配置，include配置：制定文件夹走`loader`。

`Plugin`：webpack打包过程中，会广播出去事件，`plugin`会监听到并且做一些特定的处理，一些能力的拓展

# 模块化理解

### CommonJs：

> 下个定义：代码放在一个立即执行函数中，一些module，require函数依靠闭包存储，从而完成模块化。

> 1. 在 CommonJS 中一个文件就是一个模块，模块中的变量，方法，类都是私有的
> 2. module 代表当前模块，module.exports 代表模块对外的接口
> 3. 模块在加载时所有内容会被放在一个立即执行函数中，函数的 this 指向 module.exports 这个空对象，而 exports 只是 module.exports 的引用而已
> 4. ⚠️⚠️⚠️加载模块时同步阻塞的，加载后会进行缓存，多次引入只会加载一次
> 5. require 得到的模块中变量，方法，类的拷贝，并不是直接的引用

### Es module:

> 下个定义：语法层面的模块化。一般情况下我们写的 `ES6 module` 语法会还是会通过 `bable` 等工具转化为 CommonJS 语法的。
>
> 原理：可见<a href="./打包原理.md">wbpack手写篇</a>

> 1. 在执行模块前会先加载所有的依赖模块，不论import语法在哪出现，都会将依赖的模块都先加载完毕之后，在做编译
>    这点也是最重要的一点， CommonJS 是在执行到需要加载依赖模块时，会（同步阻塞）停下当前任务去加载相应的依赖模块，而对于 ES module 来说无论你在哪一行引用依赖模块，其都会在一开始就进行加载相应的依赖模块。
> 2. import 的是变量的引用
> 3. ES module 是部分导入

### CMJ和ESM的区别

#### 区别一：动态（CM） 静态（ES）

最本质的区别在于前者对模块依赖的解决是“动态的”。而后者是“静态的”。在这里“动态”的含义是，模块依赖关系的建立发生在代码运行阶段；而“静态”则是模块依赖关系的建立发生在代码编译阶段。

Common JS：require的模块路径可以动态指定，支传入一个表达式，我们甚至可以通过if语句判断是否加载某个模块。因此，在cjs模块被执行前，并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。

ES Module： 导入、导出语句都是声明式的，它不支持导入的路径是一个表达式，并且导入导出的语句必须位于模块的顶层作用域(比如不能放在if语句中)。因此，我们说esm是一种静态的模块结构，在ES6代码的编译阶段就可以分析出模块的依赖关系。

#### 区别二：值拷贝和动态映射

在导入一个模块时，对于cjs来说获取的是一份导出值的拷贝；而在esm中则是值的动态映射，并且这个映射是只读的。

cjs：导入拷贝的值可以修改

esm：不可以对导入的值修改，如果修改会报错：会抛出SyntaxError: "count" is read-only

#### 区别三：ES Module在经过babel转化后还是成了CommonJS

```js
import a from "./a";
console.log(a);
//babel转化后：
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//ESM 被转为 CJS 时，转译器会在其导出的对象中定义一个值为 true 的私有的变量 __esModule
var _a = require("./a");
var _a2 = _interopRequireDefault(_a);
function _interopRequireDefault(obj) {
  // 如果是ESM则直接返回obj，否则返回带有default属性的新对象
  return obj && obj.__esModule ? obj : { default: obj };
}
console.log(_a2.default);
```

ESM 的export相当于往 CJS 的exports上添加属性

1. `export var/let/const/function/class...` 会往 `exports` 上添加同名属性
2. `export default` 会往 `exports` 上添加 default 属性



### 总结ES6 module 相对于 CommonJS 最大的区别就是两点：

- 在执行模块前首先需要加载所有的依赖模块，如果加载有问题直接报错
- ES6 module 的模块引入的都是变量，函数，类的引用这是很有先进性的

还有值得一提的就是 ES6 module 可以按需引入自己需要的接口，两者也是具有相同点的就是都会对已经引入的模块进行**缓存**，**如果多次引入只会执行一次**。



### 问题require，module等等都是从哪里来的

```js
(function (exports, require, module, __filename, __dirname) {
    let name = "lm";
    exports.name = name;
})({modules})
//在 CommonJS 规范中代码在运行时会被包裹在一个立即执行函数中，之后我们会改变这个立即执行函数中内部 this 的指向，指向的便是 module.exports 这个空对象。这便可以很好的解释我们 node.js 中内部 this 指向的是一个空对象的问题。

exports.name = 'sxy';//所以说console.log(this)，输出的就是exports对象
console.log(this);//{ name: 'sxy' }

```



