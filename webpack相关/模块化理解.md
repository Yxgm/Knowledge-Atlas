## CommonJS和ES Module的区别

#### 区别一：静态和动态

最本质的区别在于前者对模块依赖的解决是“动态的”。而后者是“静态的”。在这里“动态”的含义是，模块依赖关系的建立发生在代码运行阶段；而“静态”则是模块依赖关系的建立发生在代码编译阶段。

Common JS：require的模块路径可以动态指定，支传入一个表达式，我们甚至可以通过if语句判断是否加载某个模块。因此，在cjs模块被执行前，并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。

ES Module： 导入、导出语句都是声明式的，它不支持导入的路径是一个表达式，并且导入导出的语句必须位于模块的顶层作用域(比如不能放在if语句中)。因此，我们说esm是一种静态的模块结构，在ES6代码的编译阶段就可以分析出模块的依赖关系。

#### 区别二：值拷贝和动态映射

在导入一个模块时，对于cjs来说获取的是一份导出值的拷贝；而在esm中则是值的动态映射，并且这个映射是只读的。

cjs：导入拷贝的值可以修改

esm：不可以对导入的值修改，如果修改会报错：会抛出SyntaxError: "count" is read-only

#### 区别三：ES Module在经过babel转化后还是成了CommonJS

```js
import a from "./a";
console.log(a);
//babel转化后：
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//ESM 被转为 CJS 时，转译器会在其导出的对象中定义一个值为 true 的私有的变量 __esModule
var _a = require("./a");
var _a2 = _interopRequireDefault(_a);
function _interopRequireDefault(obj) {
  // 如果是ESM则直接返回obj，否则返回带有default属性的新对象
  return obj && obj.__esModule ? obj : { default: obj };
}
console.log(_a2.default);
```

ESM 的export相当于往 CJS 的exports上添加属性

1. `export var/let/const/function/class...` 会往 `exports` 上添加同名属性
2. `export default` 会往 `exports` 上添加 default 属性

### 总结ES Module的优势：

- 死代码检测和排除
- 模块变量类型检查
- 编译器优化。在cjs等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象，而esm支持直接导入变量，减少了引用层级，程序效率更高。
- 在执行模块前首先需要加载所有的依赖模块，如果加载有问题直接报错

### 问题一： require，module等等都是从哪里来的

```js
(function (exports, require, module, __filename, __dirname) {
    let name = "lm";
    exports.name = name;
})({modules})
//在 CommonJS 规范中代码在运行时会被包裹在一个立即执行函数中，之后我们会改变这个立即执行函数中内部 this 的指向，指向的便是 module.exports 这个空对象。这便可以很好的解释我们 node.js 中内部 this 指向的是一个空对象的问题。
//所以说console.log(this)，输出的就是exports对象
exports.name = 'sxy';
console.log(this);
//➜  JS练习 node "/Users/yxgm/Desktop/JS练习/js-test/a.js"
//{ name: 'sxy' }

```



