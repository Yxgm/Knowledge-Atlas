### 扫盲ajkx（JavaScript执行异步网络请求）：

ajkx是利有现有技术而组合成一套网络请求的的解决方案，我们使用`XMLHttpRequest`对象来发送一个`Ajax`请求。就是如此

#### 和http的区别：

>http是服务器/客户端对服务器的请求方式，没有ajkx之前都是http请求。
>
>ajkx/XMLhttprequest 是浏览器对服务器的请求方式，在浏览器环境下，并且AJAX请求头会多一个x-requested-with参数，值为XMLHttpRequest，
>
>##### 跨域：所以说在浏览器的同源策略下，ajkx请求存在跨域问题，而服务器之间不存在跨域，因为是服务器又不是浏览器🤔
>
>##### 跨域：仅仅是浏览器拿不到网络请求回来的数据，而不是发送不出去。⚠️

#### 本质来说：

都是Http请求

AJAX通xmlHttpRequest象请求服务器服务器接受请求返数据实现刷新交互，普通http请求通httpRequest象请求服务器接受请求返数据需要页面刷新
XMLHttpRequest是一个标准的 javascript 对象，它允许您在 javascript 中从浏览器发出 HTTP 请求.
HttpRequest是一个服务器端对象，表示对服务器的请求.
总之 - 一个在浏览器中工作，另一个在 Web 服务器中工作. 他们也有完全不同的角色. XMLHttpRequest用于在浏览器中获取 Web 资源. HttpRequest表示传入的请求.

<a href="https://juejin.cn/post/6844903816060469262#heading-10">掘金跨域</a>

项目启动dev-server的时候，会启动本地服务，将本地的一个端口，作为服务器，将我们打包好的bundle投放在服务器上，webpack的代理就是将我们向不同源的服务器请求代理到我们启用的端口上，由我们启动的服务器代理浏览器去请求数据，完成跨域。对于启用代理只是多开发环境来说。

生产环境下：打包之后后端的服务器代码和前端的包都是放在一个服务器上面，不需要跨域。开发环境下的时候需要跨域

后端node express：

```js
const express = require("express")
const app = express()
const cors = require("cors")
app.ues(cors())
```

> 即可开启cors，完成跨域（设计了请求头*），但是是不安全的，因为所有的



## 先明确一点：跨域：仅仅是浏览器屏蔽了网络请求回来的数据，而不是发送不出去。⚠️

大概的原理就是客户端会通过服务端返回的一些 `Header` 去判断该请求是否允许跨域：

比如，`Access-Control-Allow-Origin` 告诉客户端允许请求在哪些 `Origin` 下被发送，这些 `Header` 一般都是我们配在 `Server` 上的。



## 预检请求

那这么说，请求既然被发出去了，服务端又不会拦截，所以一定会被执行喽？

那当然不是，我们再回来把 `CORS` 这张图放大来看：



我们发现，在发送真正的请求之前，浏览器会先发送一个 `Preflight` 请求，也就是我们常说的预检请求，它的方法为 `OPTIONS`。

这也就是为什么有的时候我们明明只发了一个请求，在 `Network` 里却看到两个：



预检请求有一个很重要的作用就是 `询问` 服务端是不是允许这次请求，如果当前请求是个跨域的请求，你可以理解为：`询问` 服务端是不是允许请求在当前域下跨域发送。

当然，它还有其他的作用，比如 `询问` 服务端支持哪些 HTTP 方法。

## 预检的过程

当预检请求到达服务端时，服务端是不会真正执行这个请求的逻辑的，只会在这个请求上返回一些 `HTTP Header`，以此来告诉客户端是不是要发送真正的请求。

如果服务端告诉客户端，请求是允许被发送的，那真正的请求才会发出去。

比如：我在 `a.com` 这个 `origin` 下，发送了 `conardli.top` 这个域名的请求。

那么浏览器会先向  `conardli.top` 发送一个预检，预检请求不会真正执行这个域名的请求，而是返回了一些 `CORS Header`，比如 `Access-Control-Allow-Origin: a.com`

这时候浏览器发现， `conardli.top` 的请求是允许在 `a.com` 下发送的，才会真正发出请求。这时服务端才会真正执行请求接口的逻辑。



## 那么，所有的请求都会有预检吗？当然不是

## 简单请求和复杂请求

预检请求虽然不会真正在服务端执行逻辑，但也是一个请求啊，考虑到服务端的开销，不是所有请求都会发送预检的。

一旦浏览器把请求判定为 `简单请求`，浏览器就不会发送预检了。

浏览器判定请求是否为简单请求要同时满足以下四个条件：

- 使用下列方法之一：

- - `GET`
  - `HEAD`
  - `POST`

- 只使用了如下的安全 `Header`，不得人为设置其他 `Header`

- - `text/plain`
  - `multipart/form-data`
  - `application/x-www-form-urlencoded`

- - `Accept`
  - `Accept-Language`
  - `Content-Language`
  - `Content-Type` 的值仅限于下列三者之一：

- 请求中的任意 `XMLHttpRequest` 对象均没有注册任何事件监听器；`XMLHttpRequest`对象可以使用 `XMLHttpRequest.upload` 属性访问。

- 请求中没有使用 `ReadableStream` 对象。

所以，如果你发送的是一个简单请求，这个请求不管是不是会受到跨域的限制，只要发出去了，一定会在服务端被执行，浏览器只是隐藏了返回值而已。



## 总结

最后来总结下要点：

- 简单请求：不管是否跨域，只要发出去了，一定会到达服务端并被执行，浏览器只会隐藏返回值
- 复杂请求：先发预检，预检不会真正执行业务逻辑，预检通过后才会发送真正请求并在服务端被执行