## 请求头（request header）：

accept: application/json, text/plain,
accept-encoding: gzip, deflate, br
cache-control: no-cache
cookie: deviceId=c12
origin:
referer: **判断浏览器来自于哪个页面，标识访问路径**
user-agent: **用于判断 app 环境，安卓，ios 等，使用正则来匹配字符串，投放业务：向不同的 app 放入 h5 页面，用 user-agent 来判断当前所属环境**

> 为什么常见的 cdn 域名和业务域名不一样 1.安全问题，公司不想把用户信息传给 cdn
> 2.cdn request header 会携带 cookie，本来是拉一些静态的代码，不需要 cookie，但是携带了，浪费带宽

## 响应头（response header）：

access-control-allow-origin: 那些域名可以访问我
content-encoding: gzip 格式压缩
content-type: application/json;charset=UTF-8
date: Thu, 06 Aug 2020 08:15:05 GMT
set-cookie: sess=QvrAQ0 通过 set-cookie，就会被种上 cookie

## 状态码（status）：

**304 协商缓存 服务器文件未修改**

#### 面试题：

1. vue/react spa 应用，都有一个 index.html 文件，针对这个 index.html 文件，如果要做缓存，适合做什么缓存？

   > 从 spa 文件入手，插入的 js，css 文件有 hash 命名，
   > 答： 做协商缓存
   >
   > 1. 我们编译之后的 css 或者 js 文件是有 hash 命名的，而 index.html 是没有 hash 命名的，我们做的 h5 页面最大的优点就是不受限制，可以随时的迭代。
   > 2. js 文件是更新非常快的，而如何做强缓存的话，我们之前的 index 文件还是原来的 script 标签，不论我们怎么发布更新，用户看到的都是之前的，失去了 h5 的实时性的特性，而协商缓存会对比前后两次的 index 文件，如果有更新就会去服务器拉最新的文件。
   > 3. 但是一般来说，spa 的 index 文件是不做任何缓存的，他本是是非常非常小的，700B，不做缓存，几乎不消耗流量

2. 实现一个网络请求超时的函数封装？

```js
// 网络请求
function request(option) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("result");
    }, 1500);
  });
}
// 实现一个网络请求超时取消的函数;
function requestTimeOutCancel(fn, time) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject("网络请求超时，请重试");
    }, time);

    fn().then((res) => {
      resolve(res);
      clearTimeout(timer);
    });
  });
}
requestTimeOutCancel(request, 1000).then(console.log).catch(console.log);
```

> 补充：如果是 axios 或者 ajax 的话，可以设置超时时间的值
> eg:axios.timeout=5000

3.网络请求中断；

### fetch 的中断

```js
const controller = new AbortController();

fetch("http://domain/service", {
  method: "GET",
  signal: controller.signal,
});

controller.abort();
```

### axios 的中断

```js
// 方式一
// 使用 CancelToken.source 工厂方法创建一个 cancel token，
const CancelToken = axios.CancelToken;
const source = CancelToken.source();
axios.get("https://mdn.github" {
  cancelToken: source.token,
});
// 取消请求
source.cancel("Operation canceled by the user.");
// axios 为我们提供了一个 isCancel() 方法，用于判断请求的中止状态。isCancel() 方法的参数，就是我们在中止请求时自定义的信息。

// 方式二
// 通过传递一个 executor 函数到 CancelToken 的构造函数来创建一个 cancel token：

let cancel;
axios.get("/user/12345", {
  cancelToken: new axios.CancelToken(function executor(c) {
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  }),
});
// 取消请求
cancel("Operation canceled by the user.");
```

### umi-request 中断请求

umi-request 基于 fetch 封装, 兼具 fetch 与 axios 的特点, 中止请求与 fetch 和 axios
