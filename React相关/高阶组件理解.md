### 高阶组件做一些逻辑判断和一些数据共享，逻辑服用，或者可以实现反向继承

应用一：劫持props，逻辑的复用，比如一些组件共享的数据context，我们可以用高阶组件做一个中转站， 在高阶组件的内部使用一些共享数据的逻辑标签，把自己想用的组件包裹进去，然后给组件传值即可。

```jsx
const UserContext = React.createContext({ name: 'sxy', age: 20 });
export default class App extends React.Component {
  render() {
    return <Home height={1.88} />;
  }
}
// 高阶组件就是一个函数，接受组件，把一些共有的逻辑放到自己的内部逻辑，然后再传递给组件，我们编写的组件只需要关注数据的展示即可。
function exhanceComponents(Component) {
  return (props) => {
    return (
      <div>
        <UserContext.Consumer>
          {(value) => <Component {...value} {...props} />}
        </UserContext.Consumer>
      </div>
    );
  };
}
// 此处Home组件是被包裹后的组件，是被增强了的组件。！！标记的是我们原来写的Home组件,用高阶组件实现了context透传
const Home = exhanceComponents((props) => {
  return (<div>{props.name},{props.age},{props.height}</div>);
});
```

应用二：

染判断鉴权，通过高阶组件劫持传入或者别处取出的isAuth布尔值，在高阶组件内部判断，渲染相应的组件

```jsx
export default class App extends React.Component {
  render() {return <Home isAuth={false} /> }
}

function exhanceComponents(Component) {
  return (props) => {
    return <div>{props.isAuth ? <Component /> : <>无权限</>}</div>;
  };
}
//此处 
const Home = exhanceComponents((props) => <div>Home组件</div>);
```

应用三：
赋能组件-缓存生命周期 keepaliveLifeCycle，使用高阶组件包裹，让随意一个组件都被赋能

```jsx
export default class App extends React.Component {
  render() {return <Home />}
}

function withLifeCycle(Component) {
  return class extends React.PureComponent {
    UNSAFE_componentWillMount() {
      this.beginTime = Date.now();
    }
    componentDidMount() {
      this.endTime = Date.now();
      const time = this.endTime - this.beginTime;
      console.log(`组件挂载时间${time}`);
    }
    render() {
      return <Component />;
    }
  };
}

const Home = withLifeCycle((props) => <div>Home组件</div>);
```

应用四：

表单校验

```jsx
import { Input } from 'antd';
import React, { Component } from 'react';

function exhanceForm(WrapComponent) {
  //熟记只要有输入，就一定要有模型
  return class extends Component {
    constructor(props) {
      super(props);
      this.options = {};
      this.state = {};
      this.results = [];
    }
    textChange = (e) => {
      const { name, value } = e.target; //此处就是input元素
      this.setState(
        () => ({ [name]: value }),
        () => {
          //第二个函数参数，为数据已经修改后做的逻辑。相当于vue的nextTick
          this.validateField(name);
        }
      );
    };
    validateField = (name) => {
      const rules = this.options[name].rules; //[{ require: true, message: '用户名必填' }]
      const result = rules.every((item) => {
        if (item.require) {
          if (!this.state[name]) {
            //校验失败
            this.setState({
              [name + 'Message']: item.message
            });
            return false;
          }
        }
        return true;
      });

      if (result) {
        //校验成功
        this.setState({
          [name + 'Message']: ''
        });
      }
      return result;
    };

    validate = (cb) => {
      const result = Object.keys(this.options).map((item) =>
        this.validateField(item)
      );
      const res = result.every((v) => v == true);
      cb && cb(res);
    };
    getFieldDec = (field, option) => {
      this.options[field] = option;
      return (inputElement) => (
        <div>
          {this.state[field + 'Message'] && (
            <p style={{ color: 'red' }}>{this.state[field + 'Message']}</p>
          )}
          {React.cloneElement(inputElement, {
            name: field,
            value: this.state[field] || '',
            onChange: this.textChange
          })}
        </div>
      );
    };

    render() {
      return (
        <WrapComponent
          getFieldDec={this.getFieldDec}
          validate={this.validate}
        />
      );
    }
  };
}

class Form extends Component {
  render() {
    const { getFieldDec, validate } = this.props;
    const validated = (valid) => {
      if (valid) {
        alert('校验成功');
      } else {
        alert('校验失败');
      }
    };
    return (
      <div>
        {getFieldDec('name', {
          rules: [{ require: true, message: '用户名必填' }]
        })(<Input placeholder="用户名" />)}
        {/* getFieldDec方法是高阶函数上定义，通过props传入，getFieldDec函数又是一个高阶函数 */}
        {getFieldDec('pwd', {
          rules: [{ require: true, message: '密码必填' }]
        })(<Input placeholder="密码" />)}
        <button onClick={(e) => validate(validated)}>校验</button>
      </div>
    );
  }
}

export default exhanceForm(Form);

```

