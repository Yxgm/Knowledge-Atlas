# 洋葱模型

就是一层一层的函数嵌套，`data`就是我们要处理的`state`如果要是在express或者koa中，那就是我们要接受到的参数，一层一层处理之后，在传给下一个函数。

1. `Redux-Thunk`最主要的作用是帮你给异步`action`传入`dispatch`，这样你就不用从调用的地方手动传入`dispatch`，从而实现了调用的地方和使用的地方的解耦。



# 手写中间件

1. 辅助函数compose，避免函数右偏，

```js
 compose(a,b,c)("data") ==>  (c(b(a("data")))) 
//洋葱模型，为了让，左侧的写法转化成右侧，使用compare函数转化。
function compare(...arr) {
  if (arr.length === 0) return (arg) => arg; // 直接透传下去
  if (arr.length === 1) return arr[0];
  
  const [first, ...other] = arr;
  return other.reduce((pre, current) => {
    return (...args) => current(pre(...args));
  }, first);
}
```

2. reducer

```js
const initialState = {counter: 0};
function reducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':return { counter: state.counter + action.data };
    case 'RESET':return { counter: 0 };
    default: return state;
  }
}
```

3. index.js

```js
import { createStore } from 'redux'; import reducer from './reducer.js'; import compose from './compose.js'
//模拟 service request ，这不重要
function getData() {
  return new Promise((resolve) => {
    console.log('middleware function has begin ');
    setTimeout(() => resolve(100), 1000);
  });
}

function applyMiddleware(...middleWares) {
  const store = createStore(reducer); //创建store
  let dispatch = store.dispatch;
  //为什么不直接传入store.getState(),闭包导致data不变 
  const middlewareApi = {store,  dispatch};
  //闭包传入state和dispatch
  const chain = middleWares.map((middleware) => middleware(middlewareApi));
  
  // 等价于 ===> logger(thunk(dispatch))，只是写法上的不同
   dispatch = compose(...chain)(dispatch);
  return { store, dispatch };
}

  // action是用户传递进来的函数，或者是action对象，thunk是函数就执行
const thunk =
  ({ _, dispatch }) =>
  //对于最内层的函数，next 就是我们上面传递的store.dispatch函数，外层的next函数就是下一层中间件的函数逻辑
  (next) =>
  (action) => {
    if (typeof action === 'function') return action(dispatch);
    return next(action);
  };

const logger =
  ({ store, _ }) =>
  (next) =>
  async (action) => {
    console.log(store.getState());
    await next(action);
    console.log(store.getState());
  };

const { store, dispatch } = applyMiddleware(thunk, logger);
// 对于thunk中间件，自己总结如下：thunk必须要在第一个参数，
// 也就是一个洋葱模型中的最内层，最后在执行thunk逻辑。
//（因为如果thunk中判断action是function ，就会执行调用原始的dispatch，不在走包装后的dispatch逻辑）
// 洋葱模型：经过第一层中间件，第一层中间件的内部逻辑，变成next函数，并且交给下一层中间件处理，
// 一层一层的递交下去，到最后层，执行原始的dispatch函数
// 将要执行的函数逻辑，包成成next函数，再次传给外层中间件，一层一层包裹起来。

dispatch(async (dispatch) => {
  const res = await getData();
  dispatch({ type: 'INCREMENT', data: res });
});

```

