# promise相关面试题：

#### 问：为什么promise resolve了一value, 最后输出的value值确是undefined

```js
const test = new MPromise((resolve, reject) => {
  setTimeout(() => resolve('网络请求data'), 1000);
}).then(console.log);

setTimeout(() => console.log(test), 3000);
```

> 答：因为现在这种写法, 相当于在`.then`里`return undefined`, 所以最后的`value`是`undefined`,如果显式return一个值, 就不是`undefined`了；比如`return value`.

 

#### 问：为什么我在catch的回调里， 打印promise,显示状态是pending

```js
const test = new MPromise((resolve, reject) => {
  setTimeout(() => reject('失败'), 1000);
}).catch((reason) => console.log(reason, test));

setTimeout(() => console.log(test), 3000);
```

> 1. catch 函数会返回一个新的promise, 而test就是这个新promise
>
> 2. catch 的回调里, 打印promise的时候, 整个回调还并没有执行完成(所以此时的状态是pending), 只有
>
> 当整个回调完成了, 才会更改状态
>
> 3. catch 的回调函数, 如果成功执行完成了, 会改变这个新Promise的状态为fulfilled



#### 问：输出顺序

```js
Promise.resolve()
  .then(async () => {
    console.log(0);
    return Promise.resolve(4);
  })
  .then((res) => {
    console.log(res);
  });

Promise.resolve()
  .then(() => {
    console.log(1);
  })
  .then(() => {
    console.log(2);
  })
  .then(() => {
    console.log(3);
  })
  .then(() => {
    console.log(5);
  })
  .then(() => {
    console.log(6);
  });
```

> 1、在第四行，return 4，就直接是相当于return的新的promise中resolve（4）如此写法， 结果是我们预期结果，0，1，4，2，3，4，5
>
> 2、return thenable ，不是普通的值，原生promise对这种情况会多加一次queueMicrotask 输入结果为0，1，2，4，3，5，6，（为了让现有的微任务先执行，thenable对象会推迟一次）
>
> 3、return Promise.resolve(4), 不是普通的值加一次微任务，promise.resolve又多加一次微任务，一共加两次微任务。输入结果：0，1，2，3，4，5，6。
>
> Promise.resolve(4)是在执行栈为空的时候，才进入微任务队列，（不太好理解，不再花费时间）
>
> 在原生的promise中，对于then返回的值会根据不同的状况，多加不同次数的微任务，Promise.resolve会产生两个微任务，当前执行栈为空的时候，才会resolve调这个新的promise

 

更多见js高级promise面试题