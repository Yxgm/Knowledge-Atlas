# 原型上的方法：

## 1、then：

 1、用于链式调用

 2、只有promise的状态改变了，才会执行回调函数

​     3、返回值是新的一个promise的值：普通值会被包裹成一个新的promise的resolve值，返回值为状态为成功的promise，如果传入的是参数为promise对象，返回的promise的状态为参数Promise的状态，promise结果是参数Promise的结果

## 2、catch：

​     1、promise A+规范中没有这个写法，catch很特殊，在链式调用的时候，catch捕获promise的reject，如果promise中没有reject，还可以捕获then中返回的reject。

​     2、优先捕获自己的promise异常，在捕获then中的异常。

3、返回值和then机制是一样的，返回普通值的时候，也是包裹成了一个promise状态是

成功，相当于resolve。

## 3、finally：

ES2018新增特性，无论什么状态都执行一次

## 4、resolve：

状态一经改变不可更改

改变promise的状态到fulfilled

## 5、reject：

改变promise状态到fulfilled

# 静态方法（类方法）：

## 1、all方法

​    状态：只有所有的参数promise状态为成功才为成功，否则为失败；值：成功时的值为所有promise结果组成的数组，失败时为失败时的promise的结果

## 2、allSettled方法：

​    返回所有的promise的值，无论成功还是失败，包裹成一个数组返回。数组中每一个对象标识着每一个promise的status和value。（在then回调函数中拿到）

## 3、race方法：

​    返回第一个执行完的promise（无论成功还是失败），在对应的then或者catch中拿到结果

## 4、any方法：（ES12新增）

​    1、至少等到一个成功的promise，才返回结果，如果都是拒绝，会在最后才返回。

​    2、该方法接受一组Promise实例作为参数，包装成一个新的Promise实例返回，只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态。如果所有参数实例都是rejected状态，包装实例就会变成rejected状态。

## 5、resolve方法

Promise.resolve（）方式调用，包装成promise

## 6、reject方法

Promise.reject（）方法来调用，包装成promise

# Promise A规范 ：

onFulfilled函数，在promise状态变成fulfilled之后，执行此函数，参数是value。成果有成功的结果，

onRejected函数，在promise状态变成rejected之后，执行此函数，参数是reason，失败有失败的原因，

当promise状态变成fulfilled后，所有的onFulfilled回调函数，都需要按照then的注册顺序调用

onFulfilled函数和onRejected函数特性：

执行环境：微任务，queueMicrotask函数

执行机制：只能被调用一次

原因：

函数执行的时候，有副作用（会对外加产生一些影响，和本身函数变量无关的函数，eg：修改了全局变量.. ）会产生无法预期的效果。

透传机制：

如果一个promise中onFulfilled函数不是一个函数，直接把第一个promise的resolve的value给下一个promise，以promise1的value，触发fulfilled

如果一个promise的onRejected函数不是一个函数，直接把第一个promise的reject的reason给下一个promise，以promise1的reason，查法rejected

 resolvePromise函数：铲平promise对象，把promise对象一层一层的解析，解析成基本类型

 

then方法的理解：

如果new Promise时是同步的代码，then中onfilfulled函数，会被包裹成微任务函数

如果说是异步代码，then中的回调函数，会被推入到promise事例的内部的队列中，等状态改变的时候，在执行（监听status的改变）

 

