### 数据驱动：状态驱动视图

1. 状态的存储、变化、管理，再把数据的变化和视图联系起来，这就是状态管理的本质。

2. 状态决定视图，静态组件（它决定于外部传入进来的状态，staticLayout），拿到一个数据（状态）我们去处理这个状态

### 状态管理的两种方式：中心化和去中心化两种模式

1. 中心化：TJ大佬：vuex和redux就是中心化。就是一个对象。

原理：就是前一次后一次的值做一个比较，变化的话，触发通知，透传变化

2. 去中心化：没有一个根结点，useState，reactive 就是去中心化模式，自己管理自己的状态。

这也就是为什么不在使用vuex或者redux，因为框架给我们内置了去中心化的状态管理方式了（useState，reactive），替代中心化状态管理。

缺点：状态不能共享，可以发布订阅来共享数据，

**引出面试题：手写一个状态管理**

### VUEX的源码

##### vuex给我们提供最佳范式：规范我们的数据管理方式

1. module做命名空间（分形），来做多个store的管理，多状态的管理方案（乌米也是如此）

2. 定义行为，并且对用户行为进行区别（对应同步、异步）

3. 单项数据流，规定我们改变数据的方式，只能调用提供的api
4. action中传入this，可以让mutation和action串联起来

### REDUX的源码

发布订阅模式，需要通知react，然后render视图

比较灵活自由，基于hook来封装状态管理工具



###  学习这个知识点，主要是一次面试题（模拟一个vuex集中数据管理）

##### 抛出的第一个问题：vue实例身上的事件总线：

>  event对象，是挂在vue实例身上的,而on，once，off，emit方法是挂在到Vue的原型对象上的，这几个原型方法，是用混入function eventsMixin (Vue)的方法，加在vue原型对象上。
>
>  ```js
>  initMixin(Vue);
>  stateMixin(Vue);
>  eventsMixin(Vue);
>  lifecycleMixin(Vue);
>  renderMixin(Vue); //都是使用了混入的方法在vue.runtime.esm.js文件中
>  ```

平时使用的父子组件信息传递的emit和事件总线不是一回事，但是在子组件中emit出去的事件，也是放在了该vue实例身上的event属性身上(已经试验过)，$on也是将待响应回调放在了实例的_events身上。

### 第二个问题：全局事件总线

使用方法是一样的

```js
class EventBus {
  constructor() {
    this.event = {};
  }
  on(key, cb, thisArg) {
    if (!this.event[key]) {
      this.event[key] = [];
    }
    let handler = { cb, thisArg };
    this.event[key].push(handler);
  }

  off(key, cb) {
    if (!this.event[key]) return;
    this.event[key].forEach((handler, index) => {
      if (handler.cb === cb) {
        this.event[key].splice(index, 1);
      }
    });
  }
  emit(key, ...payload) {
    let keyMapCallback = this.event[key];
    if (!keyMapCallback) return;
    keyMapCallback.forEach((callback) => {
      let { cb, thisArg } = callback;
      cb.call(thisArg, ...payload);
    });
  }
}
```



### 第三个问题：实现一个数据管理

1.使用可响应式对象作为store，在main.js在初始化app之前，Vue.mixin混入生命周期，把store挂载在vue原型对象上，组件中，就可以直接使用

> **更细腻的封装请鉴       `Vue相关/手写Vuex.md`**

```js
//store.js
import Vue from 'vue';
const bus = new Vue({
  data() {
    return {
      count: 0
    };
  }
});
export default bus;

//main.js
import bus from './test/store';
Vue.mixin({
  beforeCreate() {
    Vue.prototype.$store = bus;
  }
});

//组件.vue

<h2>{{count}}</h2>
<button @click="handleBtn">点我呀</button>
export default {
  computed: { count() { return this.$store.count;}   },
  methods: { handleBtn() {this.$store.count += 1;} }
};

```

2. Vue3 中不依赖vuex，实现数据管理

```js
//state.js
import { reactive } from "vue";
export interface IState { //定义数据形状
  token: string;
  userInfo: string;
  id: number;
}
export const State: IState = {
  token: "盛祥玉",
  userInfo: "age:20",
  id: 0
};
export function createState() {
  return reactive(State);
}

//action.js
import { IState } from "./state";

export function updateToken(state: IState) {
  return (token: string) => { state.token = token; };
}
export function updateId(state: IState) {
  return (id: number) => { state.id = id; };
}
export function updateUserInfo(state: IState) {
  return (userInfo: string) => {state.userInfo = userInfo; };
}

export const createAction = (state: IState) => ({
  updateToken: updateToken(state),
  updateId: updateId(state),
  updateUserInfo: updateUserInfo(state)
});

//store.js,将state和action结合，统一导出
import { readonly } from "vue";
import { createAction } from "./action";
import { createState } from "./state";

const state = createState();
const action = createAction(state);

export default () => ({
  state: readonly(state),
  action: readonly(action)
});

//视图.vue
<h2>{{ state.token }}</h2>
<button @click="changeToken"></button>

<script setup>
import createStore from "./store";
const store = createStore();
const { state, action } = store;
const changeToken = () => {
  action.updateToken("aaa");
};
</script>

//数据持久化
import { watch, toRaw } from 'vue'
export function createPersistStorage<T>(state: any, key = 'default'): T {
    const STORAGE_KEY = '--APP-STORAGE--'

    // init value
    Object.entries(getItem(key)).forEach(([key, value]) => {
        state[key] = value
    })
	
    function setItem(state: any) {
        const stateRow = getItem()
        stateRow[key] = state
        const stateStr = JSON.stringify(stateRow)
        localStorage.setItem(STORAGE_KEY, stateStr)
    }

    function getItem(key?: string) {
        const stateStr = localStorage.getItem(STORAGE_KEY) || '{}'
        const stateRow = JSON.parse(stateStr) || {}
        return key ? stateRow[key] || {} : stateRow
    }

    watch(state, () => {
        const stateRow = toRaw(state)
        setItem(stateRow)
    })

    return readonly(state)
}

```





