# Router引出的一些问题

## 异步组件：

`Code-splitting`代码分割，为了减少首屏代码体积，往往会把一些非首屏的组件，一些我们不怎么常用，而且不是太重要的组件，设计成异步组件，按需加载。

异步组件可以减少打包的结果。会将异步组件分开打包(形成不同的chunk)，会采用异步的方式加载组件，可以有效的解决一个组件过大的问题。异步组件的核心可以给组件定义变成一个函数。

```js
component: () => import(*/\* webpackChunkName: "about" \*/* '../views/About.vue')，const compoment: React.lazy(()=>import(*/\* webpackChunkName: "about" \*/* "./About"))
```

react中引入了React.lazy和React.Suspense两个API，配合import语法即可实现异步组件，打包分割和异步加载。

```jsx
<Suspense fallback={<p>loadind...</p>}> 异步组件 </Suspense> Suspense为降级UI，报错展示UI
```

#### 异步组件手写：

```jsx
//根组件.js
export default function Home() {
  const About = lazy(
    () =>
      new Promise((resolve) => {
        setTimeout(() => {
          resolve(<div>About Component</div>);
        }, 1200);
      })
  );
  return (
    <Suspense fallback={<div>Loading....</div>}> <About /></Suspense>
  );
}

//lazy函数
function lazy(fn) {
  //lazy函数应该返回一个组件，如果返回一个jsx，那用<jsx>,那成什么了，是错误的。
  //我们思考一下，应该什么时候去请求组件，不应把一使用lazy就是去加载组件吧，应该是框架在解析的时候，
  //碰到了这个异步组件，然后再加载的，所以说应该写在返回的组件逻辑中
  let fetch = {
    status: 'pending',
    result: null,
    promise: null
  };
  return function LazyComponent() {
    React.useEffect(() => {
      if (fetch.status === 'pending') {throw fetch}
      ！！核心代码就是将promise抛出去，让外层的组件catch住，写then的逻辑
    }, []);
    fetch.promise = fn();
    if (fetch.status === 'fulfilled') {return fetch.result }
    fetch.promise.then(
      (res) => {
        fetch.status = 'fulfilled';
        fetch.result = res;
        console.log(1);//此处添加的then回调是首先执行的。
      },
      (err) => {throw { reason: err }}
    );
    return fetch.result;
  };
}

//Suspense组件
export default class Suspense extends Component {
  state = { isLoadRender: false };
  componentDidCatch(event) {//组件挂载的时候，一定是没有请求回来的状态，所以catch住，展示的是降级UI，
    this.setState({ isLoadRender: true });
    event.promise.then(() => {
      this.setState({ isLoadRender: false });
      console.log(2);//此处添加的then会调在1之后执行
    });
  }
  render() {
    const { children, fallback } = this.props;
    const { isLoadRender } = this.state;
    return <div>{isLoadRender ? fallback : children}</div>;
  }
}
```

实现文件的分割加载，`import`语法是webpack提供的，采用的就是jsonp。

> 三种异步组件：普通函数异步组件、promise异步组件、高阶异步组件（可配置的）

> 高级异步组件的实现是非常巧妙的，它实现了 loading、resolve、reject、timeout 4 种状态。异步组件实现的本质是 2 次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过 `forceRender` 强制重新渲染，这样就能正确渲染出我们异步加载的组件

#### 异步组件大概原理：

##### 概括：

**将组件独立打包成 UMD 格式的 js 文件，页面加载时通过动态生成 script标签插入该 js，插入完成后渲染组件。**

##### webpack 异步加载原理（按需加载）

`webpack ensure` 称它为异步加载，也称为代码切割，其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 `script` 对象，加入到 `document.head` 对象中，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后写个回调函数，让请求到的 js 文件做一些业务操作（挂载组件）。（中间还有`pormise.all`的操作）

> 知识补充：jsonp：script标签请求到的内容会自动执行，请求回来的回调函数的调用，后端是将把函数的调用和参数一并返回
>
> ```js
> res.end('test({"name": "sxy"})');
> ```
>
> 前端请求回来了`'test({"name": "sxy"})'`，再执行函数，即可完成函数执行

```js
//page中的server
const jsonFn = ({ name, age }) => { console.log(name, age) }
function createJSONP(url, callback) {
  var script = document.createElement("script");
  script.src = `${url}?callback=jsonFn` 
  document.body.append(script);
}
createJSONP("http://localhost:5000")

//服务端server.js
const express = require('express');
const app = express();
app.use('/', function (req, res) {
  const { callback } = req.query;
  const info = {name: 'sxy', age: 22};
  res.send(`${callback}(${JSON.stringify(info)})`);
});
app.listen(5000, () => console.log('5000 port has listen'));

//高阶版本：
function createJSONP(url, callback) {
  const script = document.createElement("script");
  script.src = `${url}?callback=${callback}`
  script.id = "script"
  return new Promise((resolve, reject) => {
    try {
      document.body.appendChild(script);
      window[callback] = (res) => resolve(res)
    } catch (err) {
      reject(err)
    } finally {
      document.body.removeChild(script)
    }
  })
}
createJSONP("http://localhost:5000", "fn").then(console.log)
```

默认的script标签是同步的，也就是当碰到script标签，会请求资源，写在script之前的html会被渲染一遍，等script加载完毕，在渲染后面的html

> **① async**: **异步加载对应的javascript脚本**，不阻塞HTML页面的渲染，当对应的javascript加载完成后，如果此时HTML页面还未加载完成，那么**会阻塞页面的渲染**，**等javascript执行完成后再继续HTML页面的加载**。
>
> **② defer**: **异步加载对应的javascript脚本**，不阻塞HTML页面的渲染，当对应的javascript加载完成后，如果此时HTML页面还未加载完成，那么**不会阻塞页面的渲染**，**等HTML页面加载完成后再接着执行加载完成的javascript脚本**。
>
> **③ type="module"**: 也是能起到异步加载的效果，效果同defer，**不过其可以配合async属性让javascript加载完成后立即执行**。
