# Router引出的一些问题

## 异步组件：

`Code-splitting`代码分割，为了减少首屏代码体积，往往会把一些非首屏的组件，一些我们不怎么常用，而且不是太重要的组件，设计成异步组件，按需加载。

异步组件可以减少打包的结果。会将异步组件分开打包(形成不同的chunk)，会采用异步的方式加载组件，可以有效的解决一个组件过大的问题。异步组件的核心可以给组件定义变成一个函数。

```js
component: () => import(*/\* webpackChunkName: "about" \*/* '../views/About.vue')，const compoment: React.lazy(()=>import(*/\* webpackChunkName: "about" \*/* "./About"))
```

react中引入了React.lazy和React.Suspense两个API，配合import语法即可实现异步组件，打包分割和异步加载。

```jsx
<Suspense fallback={<p>loadind...</p>}> 异步组件 </Suspense> Suspense为降级UI，报错展示UI
```

#### 异步组件手写：

```jsx
//根组件.js
export default function Home() {
  const About = lazy(
    () =>
      new Promise((resolve) => {
        setTimeout(() => {
          resolve(<div>About Component</div>);
        }, 1200);
      })
  );
  return (
    <Suspense fallback={<div>Loading....</div>}> <About /></Suspense>
  );
}

//lazy函数
function lazy(fn) {
  //lazy函数应该返回一个组件，如果返回一个jsx，那用<jsx>,那成什么了，是错误的。
  //我们思考一下，应该什么时候去请求组件，不应把一使用lazy就是去加载组件吧，应该是框架在解析的时候，
  //碰到了这个异步组件，然后再加载的，所以说应该写在返回的组件逻辑中
  let fetch = {
    status: 'pending',
    result: null,
    promise: null
  };
  return function LazyComponent() {
    React.useEffect(() => {
      if (fetch.status === 'pending') {throw fetch}
      ！！核心代码就是将promise抛出去，让外层的组件catch住，写then的逻辑
    }, []);
    fetch.promise = fn();
    if (fetch.status === 'fulfilled') {return fetch.result }
    fetch.promise.then(
      (res) => {
        fetch.status = 'fulfilled';
        fetch.result = res;
        console.log(1);//此处添加的then回调是首先执行的。
      },
      (err) => {throw { reason: err }}
    );
    return fetch.result;
  };
}

//Suspense组件
export default class Suspense extends Component {
  state = { isLoadRender: false };
  componentDidCatch(event) {//组件挂载的时候，一定是没有请求回来的状态，所以catch住，展示的是降级UI，
    this.setState({ isLoadRender: true });
    event.promise.then(() => {
      this.setState({ isLoadRender: false });
      console.log(2);//此处添加的then会调在1之后执行
    });
  }
  render() {
    const { children, fallback } = this.props;
    const { isLoadRender } = this.state;
    return <div>{isLoadRender ? fallback : children}</div>;
  }
}
```

实现文件的分割加载，`import`语法是webpack提供的，采用的就是jsonp。

> 三种异步组件：普通函数异步组件、promise异步组件、高阶异步组件（可配置的）

> 高级异步组件的实现是非常巧妙的，它实现了 loading、resolve、reject、timeout 4 种状态。异步组件实现的本质是 2 次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过 `forceRender` 强制重新渲染，这样就能正确渲染出我们异步加载的组件

#### 异步组件大概原理：

##### 概括：

**将组件独立打包成 UMD 格式的 js 文件，页面加载时通过动态生成 script标签插入该 js，插入完成后渲染组件。**

##### webpack 异步加载原理（按需加载）

`webpack ensure` 称它为异步加载，也称为代码切割，其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 `script` 对象，加入到 `document.head` 对象中，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后写个回调函数，让请求到的 js 文件做一些业务操作（挂载组件）。（中间还有`pormise.all`的操作）

> 知识补充：jsonp：script标签请求到的内容会自动执行，请求回来的回调函数的调用，后端是将把函数的调用和参数一并返回
>
> ```js
> res.end('test({"name": "Monkey"})');
> ```
>
> 前端请求回来了`'test({"name": "Monkey"})'`，再执行函数，即可完成函数执行

