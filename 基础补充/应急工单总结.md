## 整体的模块思路，应急响应模块（toB的增值业务，用户申请应急响应工单系统，快速处理）



#### 1. 用户查看自己当前的所有已申请应急工单，剩余次数，总次数，两栏静态显示组件（显示UI）

封装一个受控组件（数据由组件传入，当然还有背景图片和icon的不同，需要抽离配置文件用require引入，为了以后复用）

在pages页面发送网络请求，将请求回来的数据，塞到我们抽离配置函数返回的对象上去，然后再将对象传入static-layout受控组件中，完成展示。如此，那么以后有相同的UI组件，直接复用即可。



#### 2. 工单概括展示UI，（点击触发工单切换）

1. 在子组件的ticket-radio（瑞丢） 中发送了工单列表的请求，请求回来的工单列表数组存在自己的data上，并且对工单数组进行遍历，展示所有的工单，默认第一个工单时active，所以下面展示的工单信息等等都是第一个工单。在最后留有插槽。由外部决定显示UI。

> 在ticket-radio组件中最后留有插槽，不论多少个工单遍历展示之后，在外部插入（addticket 按钮），保证有序性，并且保证以后最后一个交互按钮的替换

2. 在某单个工单上，如果点击某个工单就会向父组件`emit`事件，父组件接受事件，改变自身`data`上的`current-id`，同时传给子组件的`id`也发生改变，子组件内部用`watch `监听`id`，完成响应式刷新子组件

3. 子组件中用`watch`监听的`id`，发生变化，即会重新发送一次网络请求，调用`reload`方法，刷新数据

> 开发中的小技巧
>
> 1. 网络请求回来的数据，使用`this.data= Object.assign({},data)`浅拷贝一份，不直接将data赋值
>    1. 将`null，undefined`之类过滤掉 
>    2. 该参数不是对象，则会先转成对象
>
> 2. 对于一切的网络请求数据，都要用`try catch`包裹，以防页面挂掉

##### 2.1 组件赋能的解释

比如说将一个表单封装成一个api，父组件调用一个方法，比如说getFormdata，就可以获得子表单的数据，或者得到表单的校验结果等等，

之后在次级组件中，使用这个表单。这个子组件就是我们直接放在pages上的，他的内部还有有一些提交，重置的一些按钮等等。



#### 3. 事件包装成延迟promise对象、目的： 为了让一些功能组件（新增工单，删除工单等等）异步操作同步执行。

发起应急响应事件，createTicket、更新工单事件update、删除工单事件detele

1. 点击新建工单等，在pages页面，触发子组件的run（）方法，并且将Id传入

```js
 //这是一个新增工单的dialog，点击pages上的新增按钮，触发下面事件，进入子组件的run逻辑中 
 //pages.vue
const { success } = await this.$refs.ticketCreator.run(this.ticketId);
 if (success) {this.reloadPage()}
```

2. 子组件会返回一个延迟对象promise，给父组件。（待子组件的后续操作）

```js
//ticket-creator.vue 子组件逻辑
  run() {
      if (this.deferred) return this.deferred.promise;
      this.visible = true;//组件可见
      this.deferred = new Deferred();//创建延迟对象
      return this.deferred.promise;//将延迟对象promise返回
    }
```

3.  客户填写工单信息，校验表单处理，确认申请，发出网络请求，await堵塞网络请求，待结果返回工单确认后，延迟对象的再 `resolve`出成功的标识位。同时也要处理异常的逻辑（网络请求失败等）

```js
//  结果，
await service request..
this.deferred.resolve({success: true})//延迟对象promise触发resolve，所以pages的异步逻辑返回进入then
//回调，因为pages是 await 直接拿到返回结果，判对，进入刷新页面逻辑（即刷新一些组件）
```

4. 父组件即可接到了`resolve`出来的结果，判断成功与否，成功的话，进入刷新页面的逻辑，完成新建工单的响应式处理，或者抛出异常，显示降级UI等。

### 主要接口

1. 获得工单
2. 获得工单详情



### 实习中遇到的问题：

对于每次切换tab，都会发送网络请求，导致用户的体验感不够好，都要展示降级ui，（loading）之后再跳转。

每次网络请求try 包裹，要有错误处理的UI展示

