## 做性能优化的目的是什么？

1. 首屏时间（白屏时间）
2. 首次可交互时间
3. 首次有意义的内容渲染时间



### 1.只请求当前所需要的资源

​		异步路由加载、图片懶加载（图片进入到视野内，才开始加载）、polyfill （转译高级语法）

​		https://polyfill.io/v3/ployfill.min.js 使用这个script标签，会实现转译的按需加载，阿里也有一个cdn

​		一般来说，用户需要登录状态，才可以看到页面的情况下，这样做懒加载是比较合适的

### 2.缩减资源体积

​		打包压缩 webpack4已经内置了代码压缩

​		gzip格式（资源压缩的算法）gzip：on 压缩70%~80%

​		图片格式优化（压缩图片），根据屏幕的分辨率展示不同的分辨率的图片（不需要高分辨率的图片），

​		图片格式：webp，对于想要转化图片格式转化成webp，需要判断浏览器的兼容性。

​		尽量控制cookie的大小，request header，cookie

>  尝试写一下，将其他内容的图片转化为webp格式?
>
> ```js
> //转成webp格式，需要注意：webp在浏览器中的适配，url的合法性
> function checkWebp(){
>       //转成base64，尝试转化格式，如果支持转化，则为0
>     try{  return (document.createElement('canvas').toDataURL('image/webp').indexOf('image/webp')===0) }
>     catch(e){return false}
>    }
>    const supportWebp=checkWebp()
>    function getWebpImageUrl(url){
>  if(!url) return url;//url是否为空
>  if(!supportWebp) return url//是否支持
>  if(url.startsWith('data:')){return url}//是否是base64格式
>     return url+'?/x-oss-process=image/format,webp'
>    }
>    ```
>    
> 需要浏览器适配，不同浏览器是不一样的。

### 3. 时序优化

1. js promise.all
2. ssr，seo
3.  prefetch、prerender、preload

> `<link rel="dns-prefetch" href="xxx.com"/>` 
>
> 不加这一行代码，会在真正碰到第一个请求的时候，才会去解析dns，这样造成了一定意义上的耗时。
>
> 如果加上，在加载html的时候，就直接进行了dns的预解析，节省了时间。
>
> `<link rel=preconnect href="https://aaa.com" />` 
>
> 和预解析差不多，在访问一个域名的时候，有一个优化效果
>
> `<link rel=preload as="image" href="https://aaa.com/p.png" />`
>
> 预加载图片，设置类型，加载优先级非常高，需要这样预加载（如果要是动态的话，需要构建标签，插入html）

### 4. 合理利用缓存

cdn预热（不通过用户，把原站的内容发送到全国各地的网点）cdn刷新（强制回源）cdn强制从原站拉取资源

> 为什么常见的 cdn 域名和业务域名不一样 ?
>
> 1.安全问题，公司不想把用户信息传给 cdn
> 2.cdn request header 会携带 cookie，本来是拉一些静态的代码，不需要 cookie，但是携带了，浪费带宽



如何知道自己哪个函数耗时？用装饰器模式，封装一个函数，

```js
//方法装饰器的第一个参数是类的原型对象，这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时`target`参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。

class Home extends Vue {
  longTimeFn() {
    return new Promise((resolve) => setTimeout(resolve, 100));
  }
  @measure
  async created() { await this.longTimeFn()}
}

function measure(target, name, descriptor) {
  const oldFn = descriptor.value; //属性描述对象
  descriptor.value = async function () {
    console.time(name);
    const res = oldFn.apply(this, arguments);
    console.timeEnd(name);
    return res;
  };
  return descriptor;
}

```

