## `initState`函数中：

### `initMethods`函数： 

都是同一个组件实例（vm）

### `initData`函数：

执行了observe函数，会给Vue组件实例上的data属性，添加一个`__ob__`属性，代表该data已经被observe监听。

> 第一次添加`__ob__`，很巧妙，在执行observe函数时候，直接new Observe（），在构造函数中将observe添加了上去。

Observer

属性：

```js
value: 就是data
dep：Dep对象
```

作用：`data`的监听者，标记`data`对象，并且遍历data对象，依次对属性defineReactive操作。



一个data对象对应一个observer对象，同时observer对象中拥有着data和一个它自己的dep对象。

一个data的属性对应一个Dep对象，（defineReactive中做的）

一个observer实例，拥有着



## `VUE`六大模块

### 1. `complier`：编译相关

作用：模版转成`ast` 树，`ast`树的优化，`template`转换为`render`函数，`vdom`做截流操作统一生成`dom`

> 1. `complier`中有专门的包对`template`模版作优化，也是尤大鼓励我们使用`template`
>2. `runtime-only`和`runtime-compiler`，`runtime-only`的编译阶段，让vue-template-complier完成，更推荐它，性能更高、代码量少包的体积更小




### 2. `core`：核心代码

作用：全局API封装、内置组件、vue实例化和观察者模式等等

### 3.` Platform` : 跨平台代码



### 4. `server`：服务端渲染



### 5. `sfc`：vue文件的解析器

作用：解析vue转化成js文件



### 6.`shared`：共享工具方法





initState： proxy(  ) 做了代理，去掉了中间层   vm.props.xxx=>vm.xxx,让父组件传进来的props 不用props.xxx 直接使用this.xxx

```js
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')      这就是为什么beforeCreate 没有data，props，methods等等，而create中有
```

`Vue.propotype.$set` :给对象添加某个属性，变成响应式，当对象复杂的时候，会遍历对象拖低性能，不要重复使用。相对还有$delete